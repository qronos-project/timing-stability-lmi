#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from builtins import range
import copy
from jinja2 import Environment, FileSystemLoader, StrictUndefined

import os
import sys
import numpy as np

from qronos.controlloop import DigitalControlLoop
from hybridpy import hypy

def template_dir():
    """
    directory with template_*.j2 template files
    """
    return os.path.dirname(os.path.realpath(__file__))

class HybridSysControlLoop(object):
    """
    Hybrid Automaton representation of digital control loop
    """
    def __init__(self, controlloop):
        assert isinstance(controlloop, DigitalControlLoop)
        self.s = controlloop
        self.results={}
    
    def __repr__(self):
        return "HybridSysControlLoop(" + repr(self.s) + ")"

    def to_spaceex(self):
        '''
        convert to SpaceEx format
        @return {'system': system in SpaceEx XML, 'config': configuration for spaceEx web frontend}
        '''
        self.s._check_and_update_dimensions()
        system=copy.deepcopy(self.s)

        if system.spaceex_only_simulate:
            system.x_p_0_min = system.x_p_0_max
            system.spaceex_scenario = "simu"

        context = { 'sys': system, 'set_of_io_dimensions': set([system.n_p, system.n_d])}
        output = {}
        env = Environment(autoescape=False, loader=FileSystemLoader(template_dir()), trim_blocks=True, lstrip_blocks=True, undefined=StrictUndefined)
        output['system'] = env.get_template('template_system.xml.j2').render(context)
        output['config'] = env.get_template('template_config.cfg.j2').render(context)
        return output

    def to_spaceex_files(self, path_and_prefix):
        '''
        write to files in SpaceEx format
        @param path_and_prefix output path and prefix, e.g. "./output/spaceex-example-", which will be prepended to all filenames.
        @return filename of SpaceEx XML file
        '''
        output = self.to_spaceex()
        with open(path_and_prefix + ".spaceex.xml",'w') as f:
            f.write(output['system'])
        with open(path_and_prefix + '.spaceex.cfg','w') as f:
            f.write(output['config'])
        with open(path_and_prefix + '.info.txt','w') as f:
            f.write('autogenerated. do not edit.\n To use in SpaceEx VM server: First load the .xml as Model File, then .cfg as Configuration File, then start.\n\n Model parameters:\n\n' + repr(self))
        with open(path_and_prefix + '.tex','w') as f:
            f.write(self.s.to_latex())
        return path_and_prefix + ".spaceex.xml"

    def run_analysis(self, name, outdir):
        '''
        Analyse system with SpaceEx (practical stability via fixpoint computation) and pysim (Simulation).
        This also generates plots and saves the model files used for analysis.

        @param name Title (SpaceEx "system name") for plots and other output files
        @param outdir Output directory for plots and other output files
        '''
        print("")
        print("====================")
        print("Analysing System: " + name)
        sys.stdout.flush()
        model_file = self.to_spaceex_files(outdir + name)

        # FIXME: this will modify self.s
        self.s.global_time = True
        model_file_global_time = self.to_spaceex_files(outdir + name + "__reachability_with_time_")

        self.s.spaceex_only_simulate=True
        self.to_spaceex_files(outdir + name + "__simulation_with_time_")

        self.s.spaceex_only_simulate=False
        self.s.use_urgent_semantics_and_pseudorandom_sequence = True
        model_file_pysim = self.to_spaceex_files(outdir + name + "__for_pysim__.")

        # Nominal case?
        if self.s.is_nominal_timing():
            self.results['stability_eigenvalues'] = self.s.nominal_case_stability()
        else:
            # not the nominal case, cannot test stability via eigenvalues of nominal case
            self.results['stability_eigenvalues'] = 'N/A'

        # PySim config
        # number of random initial states
        # (mostly for illustration: usually these are not near maximum x_p, and therefore the resulting trajectories are not useful to determine the interval bounds)
        pysim_rand_points=50
        if '--fast' in sys.argv:
            pysim_rand_points=3
        # additionally use initial states at corners?
        # Disabled if the number of states is large
        pysim_initstate_corners = True
        if (self.s.n_p + self.s.n_d + self.s.m + self.s.p) > 8 or '--fast' in sys.argv:
            pysim_initstate_corners = False
        pysim_options = '-star True -corners {corners} -rand {rand}'.format(corners=pysim_initstate_corners, rand=pysim_rand_points) + ' -xdim {x} -ydim 2'
        # Note for xdim/ydim: order of states in SpaceEx file: 0 = tau, 1 = t, 2...2+n-1 = x_p_1...n, ..., random_state_1 ... _(m+p)
        e = hypy.Engine('pysim', pysim_options.format(x=1))
        e.set_input(model_file_pysim)
        e.set_output(outdir + name + "_pysim.py")
        res = e.run(parse_output=True, image_path = model_file_pysim + "_pysim_plot_xp1_over_t.png")
        self.results['pysim_hypy'] = res
        assert res['code'] == hypy.Engine.SUCCESS, "running pysim failed"
        #PrettyPrinter(depth=3).pprint(res)
        pysim_state_bounds = res['output']['interval_bounds']
        #print("PySim min/max states, including simulation-internal states (global time, random number)")
        #print(pysim_state_bounds)
        print("PySim min/max states (tau, x_p_{1...n_p}, x_d_{1...n_d}, u_{1...m}, y_{1...p})")
        pysim_state_bounds = pysim_state_bounds[[0] + list(range(2, 2 + self.s.n_p + self.s.n_d + self.s.m + self.s.p)), :]
        self.results['pysim_state_bounds'] = pysim_state_bounds
        print(pysim_state_bounds)

        # PySim: plot over tau
        e = hypy.Engine('pysim', pysim_options.format(x=0))
        e.set_input(model_file_pysim)
        assert e.run(image_path = model_file_pysim + "_pysim_plot_xp1_over_tau.png")['code'] == hypy.Engine.SUCCESS, "running pysim failed"

        # SpaceEx: interval bounds
        e = hypy.Engine('spaceex', '-output-format INTV -output_vars *')
        e.set_input(model_file) # sets input model path
        res = e.run(parse_output=True, timeout=10 if "--fast" in sys.argv else 7200)
        self.results['spaceex_hypy'] = res
        print("Result: {} after {} s".format(res['code'], res['time']))
        def spaceex_bounds_to_array(res):
            variables = res['output']['variables']
            return np.block([[minmax[0], minmax[1]] for minmax in variables.values()])
        #PrettyPrinter().pprint(res)
        if res['code'] == 'Timeout (Tool)':
            self.results['stability_spaceex'] = 'timeout'
        elif res['code'] != hypy.Engine.SUCCESS:
            # Tool crashed
            print("SpaceEx or Hyst crashed: {}".format(res['code']))
            last_stdout_lines = res.get('tool_stdout', [])[-10:]
            if 'Error detected in file bflib/sgf.c at line 99' in last_stdout_lines:
                print("SpaceEx failed in GLPK library (bflib/sgf.c)")
                self.results['stability_spaceex'] = 'crash (GLPK)'
            elif any(['Segmentation fault      (core dumped)' in line for line in last_stdout_lines]):
                print("SpaceEx died with Segmentation fault")
                self.results['stability_spaceex'] = 'crash'
            elif '[stderr]  caused by: glpk 4.55returned status 1(GLP_UNDEF).' in last_stdout_lines:
                print("SpaceEx failed with GLPK-related error message GLP_UNDEF")
                self.results['stability_spaceex'] = 'error (GLPK)'
            elif '[stderr]  caused by: Support function evaluation requested for an unbounded set:' in last_stdout_lines:
                print("SpaceEx failed: unbounded set")
                self.results['stability_spaceex'] = 'unbounded'
            else:
                print("Unknown error")
                self.results['stability_spaceex'] = 'unknown failure'
            print("stdout was: ...")
            print("\n".join(last_stdout_lines))
        else:
            #res_print=deepcopy(res)
            #res_print['tool_stdout']='<omitted>'
            #res_print['stdout']='<omitted>'
            #PrettyPrinter().pprint(res_print)
            found_fixpoint = res['output']['fixpoint']
            fixpoint_warning = "(incomplete result because no fixpoint was found)" if not found_fixpoint else ""
            print("SpaceEx min/max state bounds " + fixpoint_warning)
            spaceex_state_bounds = spaceex_bounds_to_array(res)
            print(spaceex_state_bounds)
            print("K-factor (by which factor must box(simulation) be scaled to be a superset of box(analysis)? 1 = optimal, >1 = analaysis is probably pessimistic)")
            def kFactor(analysis_bounds, simulation_bounds):
                return np.max(np.max(np.abs(analysis_bounds),axis=1) / np.max(np.abs(simulation_bounds),axis=1))
            k = kFactor(spaceex_state_bounds, pysim_state_bounds)
            print("{} {}".format(k, fixpoint_warning))
            if found_fixpoint:
                # a fixpoint was found: System is practically stable (neglecting floating point inaccuracy)
                # and the state is within the computed bounds.
                self.results['stability_spaceex'] = 'stable'
                print("Stable (SpaceEx found fixpoint -- the above results are strict bounds)")
                self.results['k'] = k
                self.results['spaceex_pessimistic_state_bounds'] = spaceex_state_bounds
            else:
                self.results['k_lower_bound'] = k
                if k>1000:
                    print("SpaceEx iteration is diverging (K>1000 without finding a fixpoint)")
                    self.results['stability_spaceex'] = 'diverging'
                else:
                    print("Unknown (SpaceEx did not find fixpoint within given number of iterations -- the above results are no strict bounds!)")
                    self.results['stability_spaceex'] = 'unknown, max iterations reached'
            # SpaceEx: plot over tau
            # hypy doesn't support multiple output formats, so we need to rerun SpaceEx.
            e = hypy.Engine('spaceex', '-output-format GEN -output_vars tau,x_p_1')
            e.set_input(model_file)
            assert e.run(image_path = model_file + "__spaceex_plot_xp1_over_tau.png")['code'] == hypy.Engine.SUCCESS, "SpaceEx failed to generate plot"

            # SpaceEx: plot over global time
            e = hypy.Engine('spaceex', '-output-format GEN -output_vars t,x_p_1')
            e.set_input(model_file_global_time)
            assert e.run(image_path = model_file_global_time + "__spaceex_plot_xp1_over_t.png")['code'] == hypy.Engine.SUCCESS, "SpaceEx failed to generate plot"

            # Flowstar: plot over global time

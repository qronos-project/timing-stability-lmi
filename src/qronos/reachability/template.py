
#!/usr/bin/env python2
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function


# TODO make this file work again

import os
import shutil
import copy
import logging
import pickle
from jinja2 import Environment, FileSystemLoader, StrictUndefined

import sys
import numpy as np

from .. import examples

hypy_available = False
try:
    from hybridpy import hypy
    hypy_available = True
except ImportError as e:
    logging.warning("hypy not found, some functions will be unavailable")
    if not "--ignore-hypy" in sys.argv:
        logging.fatal("hypy not found. Use --ignore-hypy to ignore that.")
        raise e
        sys.exit(1)


os.chdir(os.path.dirname(sys.argv[0]))
if not os.path.isfile("template_system.xml.j2"):
    print("must be run from within the script directory as ./template.py")
    sys.exit(1)


    def to_spaceex(self):
        '''
        convert to SpaceEx format
        @return {'system': system in SpaceEx XML, 'config': configuration for spaceEx web frontend}
        '''
        self._check_and_update_dimensions()
        system=copy.deepcopy(self)

        if system.spaceex_only_simulate:
            system.x_p_0_min = system.x_p_0_max
            system.spaceex_scenario = "simu"

        context = { 'sys': system, 'set_of_io_dimensions': set([system.n_p, system.n_d])}
        output = {}
        env = Environment(autoescape=False, loader=FileSystemLoader('./'), trim_blocks=True, lstrip_blocks=True, undefined=StrictUndefined)
        output['system'] = env.get_template('template_system.xml.j2').render(context)
        output['config'] = env.get_template('template_config.cfg.j2').render(context)
        return output

    def to_spaceex_files(self, path_and_prefix):
        '''
        write to files in SpaceEx format
        @param path_and_prefix output path and prefix, e.g. "./output/spaceex-example-", which will be prepended to all filenames.
        @return filename of SpaceEx XML file
        '''
        output = self.to_spaceex()
        with open(path_and_prefix + ".spaceex.xml",'w') as f:
            f.write(output['system'])
        with open(path_and_prefix + '.spaceex.cfg','w') as f:
            f.write(output['config'])
        with open(path_and_prefix + '.info.txt','w') as f:
            f.write('autogenerated. do not edit.\n To use in SpaceEx VM server: First load the .xml as Model File, then .cfg as Configuration File, then start.\n\n Model parameters:\n\n' + repr(self))
        with open(path_and_prefix + '.tex','w') as f:
            f.write(self.to_latex())
        return path_and_prefix + ".spaceex.xml"
    
    def run_analysis(self, name, outdir="./output/"):
        '''
        Analyse system with SpaceEx (practical stability via fixpoint computation) and pysim (Simulation).
        This also generates plots and saves the model files used for analysis.
        
        @param name System name for plots and other output files
        @param outdir Output directory for plots and other output files
        '''
        print("")
        print("====================")
        print("Analysing System: " + name)
        sys.stdout.flush()
        # NOTE: Hyst's SpaceEx-conversion doesn't like dashes in filenames. (Bugfix submitted: https://github.com/verivital/hyst/pull/43 )
        model_file = system.to_spaceex_files(outdir+name)
        
        system.global_time = True
        model_file_global_time = system.to_spaceex_files(outdir + name + "__reachability_with_time_")
        
        system.spaceex_only_simulate=True
        system.to_spaceex_files(outdir + name + "__simulation_with_time_")
        
        system.spaceex_only_simulate=False
        system.use_urgent_semantics_and_pseudorandom_sequence = True
        model_file_pysim = system.to_spaceex_files(outdir + name + "__for_pysim__.")
        
        # Nominal case?
        if system.is_nominal_timing():
            system.results['stability_eigenvalues'] = system.nominal_case_stability()
        else:
            # not the nominal case, cannot test stability via eigenvalues of nominal case
            system.results['stability_eigenvalues'] = 'N/A'
        
        if not hypy_available:
            logging.warning("hypy is unavailable. Not running SpaceEx and other tools.")
            return
        
        # PySim config
        # number of random initial states
        # (mostly for illustration: usually these are not near maximum x_p, and therefore the resulting trajectories are not useful to determine the interval bounds)
        pysim_rand_points=50
        if '--fast' in sys.argv:
            pysim_rand_points=3
        # additionally use initial states at corners?
        # Disabled if the number of states is large
        pysim_initstate_corners = True
        if (system.n_p + system.n_d + system.m + system.p) > 8 or '--fast' in sys.argv:
            pysim_initstate_corners = False
        pysim_options = '-star True -corners {corners} -rand {rand}'.format(corners=pysim_initstate_corners, rand=pysim_rand_points) + ' -xdim {x} -ydim 2'
        # Note for xdim/ydim: order of states in SpaceEx file: 0 = tau, 1 = t, 2...2+n-1 = x_p_1...n, ..., random_state_1 ... _(m+p)
        e = hypy.Engine('pysim', pysim_options.format(x=1))
        e.set_input(model_file_pysim)
        e.set_output(outdir + name + "_pysim.py")
        res = e.run(parse_output=True, image_path = model_file_pysim + "_pysim_plot_xp1_over_t.png")
        system.results['pysim_hypy'] = res
        assert res['code'] == hypy.Engine.SUCCESS, "running pysim failed"
        #PrettyPrinter(depth=3).pprint(res)
        pysim_state_bounds = res['output']['interval_bounds']
        #print("PySim min/max states, including simulation-internal states (global time, random number)")
        #print(pysim_state_bounds)
        print("PySim min/max states (tau, x_p_{1...n_p}, x_d_{1...n_d}, u_{1...m}, y_{1...p})")
        pysim_state_bounds = pysim_state_bounds[[0] + range(2, 2 + system.n_p + system.n_d + system.m + system.p), :]
        system.results['pysim_state_bounds'] = pysim_state_bounds
        print(pysim_state_bounds)
        
        # PySim: plot over tau
        e = hypy.Engine('pysim', pysim_options.format(x=0))
        e.set_input(model_file_pysim)
        assert e.run(image_path = model_file_pysim + "_pysim_plot_xp1_over_tau.png")['code'] == hypy.Engine.SUCCESS, "running pysim failed"
        
        # SpaceEx: interval bounds
        e = hypy.Engine('spaceex', '-output-format INTV -output_vars *')
        e.set_input(model_file) # sets input model path
        res = e.run(parse_output=True, timeout=10 if "--fast" in sys.argv else 7200)
        system.results['spaceex_hypy'] = res
        print("Result: {} after {} s".format(res['code'], res['time']))
        def spaceex_bounds_to_array(res):
            variables = res['output']['variables']
            return np.block([[minmax[0], minmax[1]] for minmax in variables.itervalues()])
        #PrettyPrinter().pprint(res)
        if res['code'] == 'Timeout (Tool)':
            self.results['stability_spaceex'] = 'timeout'
        elif res['code'] != hypy.Engine.SUCCESS:
            # Tool crashed
            print("SpaceEx or Hyst crashed: {}".format(res['code']))
            last_stdout_lines = res.get('tool_stdout', [])[-10:]
            if 'Error detected in file bflib/sgf.c at line 99' in last_stdout_lines:
                print("SpaceEx failed in GLPK library (bflib/sgf.c)")
                self.results['stability_spaceex'] = 'crash (GLPK)'
            elif any(['Segmentation fault      (core dumped)' in line for line in last_stdout_lines]):
                print("SpaceEx died with Segmentation fault")
                self.results['stability_spaceex'] = 'crash'
            elif '[stderr]  caused by: glpk 4.55returned status 1(GLP_UNDEF).' in last_stdout_lines:
                print("SpaceEx failed with GLPK-related error message GLP_UNDEF")
                self.results['stability_spaceex'] = 'error (GLPK)'
            elif '[stderr]  caused by: Support function evaluation requested for an unbounded set:' in last_stdout_lines:
                print("SpaceEx failed: unbounded set")
                self.results['stability_spaceex'] = 'unbounded'
            else:
                print("Unknown error")
                self.results['stability_spaceex'] = 'unknown failure'
            print("stdout was: ...")
            print("\n".join(last_stdout_lines))
        else:
            #res_print=deepcopy(res)
            #res_print['tool_stdout']='<omitted>'
            #res_print['stdout']='<omitted>'
            #PrettyPrinter().pprint(res_print)
            found_fixpoint = res['output']['fixpoint']
            fixpoint_warning = "(incomplete result because no fixpoint was found)" if not found_fixpoint else ""
            print("SpaceEx min/max state bounds " + fixpoint_warning)
            spaceex_state_bounds = spaceex_bounds_to_array(res)
            print(spaceex_state_bounds)
            print("K-factor (by which factor must box(simulation) be scaled to be a superset of box(analysis)? 1 = optimal, >1 = analaysis is probably pessimistic)")
            def kFactor(analysis_bounds, simulation_bounds):
                return np.max(np.max(np.abs(analysis_bounds),axis=1) / np.max(np.abs(simulation_bounds),axis=1))
            k = kFactor(spaceex_state_bounds, pysim_state_bounds)
            print("{} {}".format(k, fixpoint_warning))
            if found_fixpoint:
                # a fixpoint was found: System is practically stable (neglecting floating point inaccuracy)
                # and the state is within the computed bounds.
                self.results['stability_spaceex'] = 'stable'
                print("Stable (SpaceEx found fixpoint -- the above results are strict bounds)")
                self.results['k'] = k
                self.results['spaceex_pessimistic_state_bounds'] = spaceex_state_bounds
            else:
                self.results['k_lower_bound'] = k
                if k>1000:
                    print("SpaceEx iteration is diverging (K>1000 without finding a fixpoint)")
                    self.results['stability_spaceex'] = 'diverging'
                else:
                    print("Unknown (SpaceEx did not find fixpoint within given number of iterations -- the above results are no strict bounds!)")
                    self.results['stability_spaceex'] = 'unknown, max iterations reached'
            # SpaceEx: plot over tau
            # hypy doesn't support multiple output formats, so we need to rerun SpaceEx.
            e = hypy.Engine('spaceex', '-output-format GEN -output_vars tau,x_p_1')
            e.set_input(model_file)
            assert e.run(image_path = model_file + "__spaceex_plot_xp1_over_tau.png")['code'] == hypy.Engine.SUCCESS, "SpaceEx failed to generate plot"
            
            # SpaceEx: plot over global time
            e = hypy.Engine('spaceex', '-output-format GEN -output_vars t,x_p_1')
            e.set_input(model_file_global_time)
            assert e.run(image_path = model_file_global_time + "__spaceex_plot_xp1_over_t.png")['code'] == hypy.Engine.SUCCESS, "SpaceEx failed to generate plot"
            
            # Flowstar: plot over global time




if os.path.exists("./output/") and not "--load" in sys.argv:
    shutil.rmtree("./output/")
for directory in ["./output/unsolved/unknown", "./output/unsolved/unstable", "./output/unsolved/stable", "./output/solved_with_spaceex/stable"]:
    if not os.path.exists(directory):
        os.makedirs(directory)

# Files are denoted with a unique prefix (e.g. A1) to simplify referencing them in publications
systems={}
systems['solved_with_spaceex/stable/A1_1']=example_A1_stable_1()
if not "--fast" in sys.argv:
    systems['solved_with_spaceex/stable/A2_1']=example_A2_stable_1()
    systems['solved_with_spaceex/stable/A3_1']=example_A3_stable_1()
    systems['unsolved/unknown/A4_1']=example_A4_unknown_1()
    systems['unsolved/stable/A5_diagonal_2']=example_A5_stable_diagonal(2)
    systems['solved_with_spaceex/stable/B1_stable_3']=example_B1_stable_3()
    systems['unsolved/stable/C1_quadrotor_one_axis_no_jitter_1']=example_C_quadrotor_attitude_one_axis(perfect_timing=True)
    systems['unsolved/unknown/C2_quadrotor_one_axis_with_jitter_1']=example_C_quadrotor_attitude_one_axis(perfect_timing=False)
    systems['unsolved/stable/D1_quadrotor_attitude_three_axis_no_jitter_3']=example_D_quadrotor_attitude_three_axis(perfect_timing=True)
    systems['unsolved/unknown/D2_quadrotor_attitude_three_axis_with_jitter_3']=example_D_quadrotor_attitude_three_axis(perfect_timing=False)
    systems['unsolved/unstable/E_timer']=example_E_timer()
    assert systems['unsolved/unstable/E_timer'].nominal_case_stability() == 'borderline unstable'

# Test that systems marked as 'stable' are actually stable
for (key, system) in systems.iteritems():
    if '/stable' in key:
        if all(system.delta_t_u_min <= 0) and all(system.delta_t_y_min <= 0) \
        and all(system.delta_t_u_max >= 0) and all(system.delta_t_y_max >= 0):
            # first sanity check (not sufficient, only necessary):
            # if the nominal case delta_t=0 is included in the possible timings,
            # then, a stable system's nominal case (delta_t=0) must be stable too:
            assert system.nominal_case_stability() == 'stable'

        # sufficient stability tests:
        if key.startswith('solved_'):
            # the system was verified by manually calling some verification program.
            pass
        elif key == 'unsolved/stable/A5_diagonal_2':
            # The system A5_diagonal_x is the diagonal repetition of example A1, which is stable (shown by SpaceEx),
            # so A5_diagonal_x must be stable as well.
            assert 'solved_with_spaceex/stable/A1_1' in systems
        else:
            # if the system hasn't been verified with SpaceEx, but is marked as stable,
            # we need to show that it's stable using some stability test.
            # Currently, only one possibility is implemented:
            # - The timing is only the nominal case, and the nominal case is stable.
            # (Future work could include less restrictive stability tests.)
            assert system.is_nominal_timing() and system.nominal_case_stability() == 'stable', \
                'system {} is marked stable and unsolved, but stability could not be tested: It is marked as unsolved, i.e. not verified by SpaceEx or some other tool. A simplified stability test was not applicable because the timing is not strictly zero.'.format(key)


# If system names (the keys of systems[]) are given on the command line, process only these.
# NOTE: invalid names will be ignored.
requested_system_names = set(systems.iterkeys()).intersection(set(sys.argv))
if requested_system_names:
    print("Example names were given on the command line. Only processing these: {}".format(", ".join(requested_system_names)))
    systems = {name: system for (name, system) in systems.iteritems() if name in requested_system_names}

if "--load" in sys.argv:
    # Load results from file
    with open("./output/systems.pickle", "rb") as f:
        systems=pickle.load(f)
else:
    # Save systems to files, run analysis and simulation
    for (name, system) in sorted(systems.iteritems()):
        try:
            system.run_analysis(name)
            if not "--ignore-hypy" in sys.argv:
                if name.startswith("solved"):
                    assert system.results['spaceex_hypy']['code'] == hypy.Engine.SUCCESS, "SpaceEx failed, but the system is marked as solved"
                else:
                    # "unsolved" system: either SpaceEx crash or SpaceEx fails to compute fixout
                    assert system.results['spaceex_hypy']['code'] != hypy.Engine.SUCCESS or not system.results['spaceex_hypy']['output'].get('fixpoint', False), "System marked as unsolved, but SpaceEx succeeded!"
        except Exception:
            logging.error("Failed to process system {}".format(name))
            raise
    with open("./output/systems.pickle", "wb") as f:
        pickle.dump(systems, f)


# Manual modifications to LaTeX table
# System E is unstable (plant is double integrator without input)
if 'unsolved/unstable/E_timer' in systems:
    assert np.all(systems['unsolved/unstable/E_timer'].A_p == np.array([[0, 1], [0, 0]]))
    assert np.all(systems['unsolved/unstable/E_timer'].B_p == 0)
    systems['unsolved/unstable/E_timer'].results['stability_eigenvalues'] = 'unstable'
    systems['unsolved/unstable/E_timer'].results['stability_spaceex'] = 'N/A'



# Generate LaTeX table
print("producing LaTeX table")
def format_spaceex_columns(system):
    def format_spaceex_result(stability, time):
        if stability == "stable":
            return r"\checkmark"
        elif stability=="N/A":
            return "---"
        else:
            return r"$\times$ " + stability
    def format_spaceex_runtime(stability, time):
        if stability.startswith("crash") or stability=="N/A" or stability.startswith("diverging") or stability.startswith("error"):
            return "---"
        if stability.startswith("timeout") and time >= 7200:
            return "---"
        return "{:.0f}\,s".format(time)
    stability = system.results.get('stability_spaceex', "NOT RUN")
    time = system.results.get('spaceex_hypy', {}).get('time', -1)
    return {'result':  format_spaceex_result(stability, time),
            'runtime':  format_spaceex_runtime(stability, time)}

from ..util.latex_table import generate_table, format_float_ceil

for (name, system) in sorted(systems.iteritems()):
    system.name = name
# [ ('column name', 'alignment', lambda system: generate_column_from_system(system)), ... ]
columns = [ ('name', 'l|', lambda s: s.name.split("/")[-1].split("_")[0]),
            (r'$n\idxPlant$', 'c',  lambda s: s.n_p),
            (r'$n\idxDiscrete$', 'c', lambda s: s.n_d),
            ('$m$', 'c', lambda s: s.m),
            ('$p$', 'c', lambda s: s.p),
            ('timing', 'l|', lambda s: 'constant' if s.is_fixed_timing() else 'varying'),
            ('SpaceEx', 'l', lambda s: format_spaceex_columns(s)['result']),
            (r'$t_{\mathrm{SE}}$', 'r', lambda s: format_spaceex_columns(s)['runtime']),
            (r'$K_{\mathrm{SE}}$', 'r|', lambda s: format_float_ceil(s.results['k'], digits=3) if 'k' in s.results else '---'),
            ('LTI-stability', 'l', lambda s: s.results['stability_eigenvalues'].replace("N/A","---"))
        ]



table = generate_table(columns, sorted(systems.itervalues(), key = lambda s: s.name.split("/")[-1]))
print(table)
with open("./output/results.tex", "w") as f:
    f.write(table)

if "--fast" in sys.argv:
    print("CAUTION: The script was run with --fast, which means that the results are imprecise and/or useless. Use this ONLY for testing the code, NEVER for publication-ready results.")



if os.path.exists("./output/") and not "--load" in sys.argv:
    shutil.rmtree("./output/")
for directory in ["./output/unsolved/unknown", "./output/unsolved/unstable", "./output/unsolved/stable", "./output/solved_with_spaceex/stable"]:
    if not os.path.exists(directory):
        os.makedirs(directory)

# TODO: merge back to 'examples' class

# Files are denoted with a unique prefix (e.g. A1) to simplify referencing them in publications
systems={}
systems['solved_with_spaceex/stable/A1_1']=examples.example_A1_stable_1()
if not "--fast" in sys.argv:
    systems['solved_with_spaceex/stable/A2_1']=examples.example_A2_stable_1()
    systems['solved_with_spaceex/stable/A3_1']=examples.example_A3_stable_1()
    systems['unsolved/unknown/A4_1']=examples.example_A4_unknown_1()
    systems['unsolved/stable/A5_diagonal_2']=examples.example_A5_stable_diagonal(2)
    systems['solved_with_spaceex/stable/B1_stable_3']=examples.example_B1_stable_3()
    systems['unsolved/stable/C1_quadrotor_one_axis_no_jitter_1']=examples.example_C_quadrotor_attitude_one_axis(perfect_timing=True)
    systems['unsolved/unknown/C2_quadrotor_one_axis_with_jitter_1']=examples.example_C_quadrotor_attitude_one_axis(perfect_timing=False)
    systems['unsolved/stable/D1_quadrotor_attitude_three_axis_no_jitter_3']=examples.example_D_quadrotor_attitude_three_axis(perfect_timing=True)
    systems['unsolved/unknown/D2_quadrotor_attitude_three_axis_with_jitter_3']=examples.example_D_quadrotor_attitude_three_axis(perfect_timing=False)
    systems['unsolved/unstable/E_timer']=examples.example_E_timer()
    assert systems['unsolved/unstable/E_timer'].nominal_case_stability() == 'borderline unstable'

# Test that systems marked as 'stable' are actually stable
for (key, system) in systems.iteritems():
    if '/stable' in key:
        if all(system.delta_t_u_min <= 0) and all(system.delta_t_y_min <= 0) \
        and all(system.delta_t_u_max >= 0) and all(system.delta_t_y_max >= 0):
            # first sanity check (not sufficient, only necessary):
            # if the nominal case delta_t=0 is included in the possible timings,
            # then, a stable system's nominal case (delta_t=0) must be stable too:
            assert system.nominal_case_stability() == 'stable'

        # sufficient stability tests:
        if key.startswith('solved_'):
            # the system was verified by manually calling some verification program.
            pass
        elif key == 'unsolved/stable/A5_diagonal_2':
            # The system A5_diagonal_x is the diagonal repetition of example A1, which is stable (shown by SpaceEx),
            # so A5_diagonal_x must be stable as well.
            assert 'solved_with_spaceex/stable/A1_1' in systems
        else:
            # if the system hasn't been verified with SpaceEx, but is marked as stable,
            # we need to show that it's stable using some stability test.
            # Currently, only one possibility is implemented:
            # - The timing is only the nominal case, and the nominal case is stable.
            # (Future work could include less restrictive stability tests.)
            assert system.is_nominal_timing() and system.nominal_case_stability() == 'stable', \
                'system {} is marked stable and unsolved, but stability could not be tested: It is marked as unsolved, i.e. not verified by SpaceEx or some other tool. A simplified stability test was not applicable because the timing is not strictly zero.'.format(key)

